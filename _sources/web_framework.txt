
OpenERP Web Framework
=====================

In the first part of this guide, we explained the JavaScript language and some libraries commonly used with it (jQuery
and Underscore.js). Still, we lack some serious features to be able to program effectively for a big program like
OpenERP. We don't really have tools for object oriented programming, no structure for graphical user interfaces
conception, our helpers to request data from the server are too basic, etc...

That's why the OpenERP web client contains a web development framework to provide structure and the necessary features
for everyday programming. The current part will explain that framework.

A Simple Module to Test the Web Framework
-----------------------------------------

It's not really possible to include the multiple JavaScript files that constitute the OpenERP web framework in a simple
HTML file like we did in the previous chapter. So we will create a simple module in OpenERP that contains some
configuration to have a web component that will give us the possibility to test the web framework.

To download the example module, use this bazaar command:

.. code-block:: sh

    bzr branch bzr+ssh://bazaar.launchpad.net/~niv-openerp/+junk/oepetstore/ -r 1

Now you must add that folder to your the addons path when you launch OpenERP (``--addons-path`` parameter when you
launch the ``openerp-server`` executable). Then create a new database and install the new module ``oepetstore``.

Now let's see what files exist in that module:

.. code-block:: text

    oepetstore
    |-- __init__.py
    |-- __openerp__.py
    |-- petstore_data.xml
    |-- petstore.py
    |-- petstore.xml
    `-- static
        `-- src
            |-- css
            |   `-- petstore.css
            |-- js
            |   `-- petstore.js
            `-- xml
                `-- petstore.xml

This new module already contains some customization that should be easy to understand if you already coded an OpenERP
module like a new table, some views, menu items, etc... We'll come back to these elements later because they will
be useful to develop some example web module. Right now let's concentrate on the essential: the files dedicated to web
development.

Please note that all files to be used in the web part of an OpenERP module must always be placed in a ``static`` folder
inside the module. This is mandatory due to possible security issues. The fact we created the folders ``css``, ``js``
and ``xml`` is just a convention.

``oepetstore/static/css/petstore.css`` is our CSS file. It is empty right now but we will add any CSS we need later.

``oepetstore/static/xml/petstore.xml`` is an XML file that will contain our QWeb templates. Right now it is almost
empty too. Those templates will be explained later, in the part dedicated to QWeb templates.

``oepetstore/static/js/petstore.js`` is probably the most interesting part. It contains the JavaScript of our
application. Here is what it looks like right now:

::

    openerp.oepetstore = function(instance) {
        var _t = instance.web._t,
            _lt = instance.web._lt;
        var QWeb = instance.web.qweb;

        instance.oepetstore = {};

        instance.oepetstore.HomePage = instance.web.Widget.extend({
            start: function() {
                console.log("pet store home page loaded");
            },
        });
        
        instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');
    }

The multiple components of that file will explained progressively. Just know that it doesn't do much things right
now except display a blank page and print a small message in the console.

Like OpenERP's XML files containing views or data, these files must be indicated in the ``__openerp__.py`` file. Here
are the lines we added to explain to the web client it has to load these files:

::

    'js': ['static/src/js/*.js'],
    'css': ['static/src/css/*.css'],
    'qweb': ['static/src/xml/*.xml'],

These configuration parameters use wildcards, so we can add new files without altering ``__openerp__.py``:
they will be loaded by the web client as long as they have the correct extension and are in the correct folder.

.. warning::

    In OpenERP, all JavaScript files are, by default, concatenated in a single file. Then we apply an operation called
    the *minification* on that file. The minification will remove all comments, white spaces and line-breaks in the
    file. Finally, it is sent to the user's browser.

    That operation may seem complex, but it's a common procedure in big application like OpenERP with a lot of
    JavaScript files. It allows to load the application a lot faster.

    It has the main drawback to make the application almost impossible to debug, which is very bad to develop. The
    solution to avoid this side-effect and still be able to debug is to append a small argument to the URL used to
    load OpenERP: ``?debug``. So the URL will look like this:

    .. code-block:: text

        http://localhost:8069/?debug

    When you use that type of URL, the application will not perform all that concatenation-minification process on the
    JavaScript files. The application will take more time to load but you will be able to develop with decent
    debugging tools.

OpenERP JavaScript Module
-------------------------

In the previous chapter, we explained that JavaScript do not have a correct mechanism to namespace the variables
declared in different JavaScript files and we proposed a simple method called the Module pattern.

In OpenERP's web framework there is an equivalent of that pattern which is integrated with the rest of the framework.
Please note that **an OpenERP web module is a separate concept from an OpenERP addon**. An addon is a folder with
a lot of files, a web module is not much more than a namespace for JavaScript.

The ``oepetstore/static/js/petstore.js`` already declare such a module:

::

    openerp.oepetstore = function(instance) {
        instance.oepetstore = {};

        instance.oepetstore.xxx = ...;
    }

In OpenERP's web framework, you declare a JavaScript module by declaring a function that you put in the global variable
``openerp``. The attribute you set in that object must have the exact same name than your OpenERP addon (this addon
is named ``oepetstore``, if I set ``openerp.petstore`` instead of ``openerp.oepetstore`` that will not work).

That function will be called when the web client decides to load your addon. It is given a parameter named ``instance``,
which represents the current OpenERP web client instance and contains all the data related to the current session as well
as the variables of all web modules.

The convention is to create a new namespace inside the ``instance`` object which has the same name than you addon.
That's why we set an empty dictionary in ``instance.oepetstore``. That dictionary is the namespace we will use to
declare all classes and variables used inside our module.

Classes
-------

JavaScript doesn't have a class mechanism like most object-oriented programming languages. To be more exact, it provides
language elements to make object-oriented programming but you have to define by yourself how you choose to do it.
OpenERP's web framework provide tools to simplify this and let programmers code in a similar way they would program
in other languages like Java. That class system is heavily inspired by John Resig's `Simple JavaScript Inheritance
<http://ejohn.org/blog/simple-javascript-inheritance/>`_.

To define a new class, you need to inherit from the ``instance.web.Class`` class. Here is the syntax to do so:

::

    instance.oepetstore.MyClass = instance.web.Class.extend({
        say_hello: function() {
            console.log("hello");
        },
    });

As you can see, you have to call the ``instance.web.Class.extend()`` method and give it a dictionary. That dictionary
will contain the methods and class attributes of our new class. Here we simply put a method named ``say_hello()``. This
class can be instantiated and used like this:

::

    var my_object = new instance.oepetstore.MyClass();
    my_object.say_hello();
    // print "hello" in the console

You can access the attributes of a class inside a method using ``this``:

::

    instance.oepetstore.MyClass = instance.web.Class.extend({
        say_hello: function() {
            console.log("hello", this.name);
        },
    });

    var my_object = new instance.oepetstore.MyClass();
    my_object.name = "Nicolas";
    my_object.say_hello();
    // print "hello Nicolas" in the console

Classes can have a constructor, it is just a method named ``init()``. You can pass parameters to the constructor like
in most language:

::

    instance.oepetstore.MyClass = instance.web.Class.extend({
        init: function(name) {
            this.name = name;
        },
        say_hello: function() {
            console.log("hello", this.name);
        },
    });

    var my_object = new instance.oepetstore.MyClass("Nicolas");
    my_object.say_hello();
    // print "hello Nicolas" in the console

Classes can be inherited. To do so, use the ``extend()`` directly on your class just like you extended the
``instance.web.Class`` class:

::

    instance.oepetstore.MySpanishClass = instance.oepetstore.MyClass.extend({
        say_hello: function() {
            console.log("hola", this.name);
        },
    });

    var my_object = new instance.oepetstore.MySpanishClass("Nicolas");
    my_object.say_hello();
    // print "hola Nicolas" in the console

When overriding a method using inheritance, you can use ``this._super()`` to call the original method. ``this._super()``
is not a normal method of your class, you can consider it's magic. Example:

::

    instance.oepetstore.MySpanishClass = instance.oepetstore.MyClass.extend({
        say_hello: function() {
            this._super();
            console.log("translation in Spanish: hola", this.name);
        },
    });

    var my_object = new instance.oepetstore.MySpanishClass("Nicolas");
    my_object.say_hello();
    // print "hello Nicolas \n translation in Spanish: hola Nicolas" in the console

Widgets Basics
--------------

In previous chapter we discovered jQuery and its DOM manipulation tools. It's useful, but it's not sufficient to
structure a real application. Graphical user interface libraries like Qt, GTK or Windows Forms have classes to
represent visual components. In OpenERP, we have the ``Widget`` class. A widget is a generic component dedicated to
display content to the user.

The Client Action
%%%%%%%%%%%%%%%%%

The start module you installed already contains a small widget, it's also what we call a ``client action``. See the
code:

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            console.log("pet store home page loaded");
        },
    });
    
    instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');

Here we create a simple widget by extending the ``instance.web.Widget`` class. This one defines a method named
``start()`` that doesn't do anything really interesting right now. We'll come back on that method later.

The last line registers our basic widget as a client action. To understand the usefulness of this, take a
look at the OpenERP action definition located at the beginning of the ``oepetstore/petstore.xml`` OpenERP XML data file:

.. code-block:: xml

    <record id="action_home_page" model="ir.actions.client">
        <field name="name">Inbox</field>
        <field name="tag">petstore.homepage</field>
    </record>

    <menuitem id="home_page_petstore_menu" name="Home Page" parent="petstore_menu"
        action="action_home_page"/>

If you are an OpenERP addon programmer, should already know at least one type of action: the action ``act_window``. That
type of action displays an OpenERP view like a form view, a list view or any other type of standard OpenERP view. Here
we declare a different type of OpenERP action: a client action.

Client actions are dedicated to be used with a web module part. That action simply tells OpenERP's web client "open the
client action identified by the key ``petstore.homepage``". Let's come back to the JavaScript code that declared our
client action:

::

    instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');

Calling the ``instance.web.client_actions.add()`` method like this simply tells the web client "If someone asks you to
open a client action with key ``petstore.homepage``, instantiate the ``instance.oepetstore.HomePage`` class and show
it to the user".

Due to this declaration, if you go in the menu ``Pet Store > Pet Store > Home Page`` you will see an empty page, but
the JavaScript console will print "pet store home page loaded". This means the widget was correctly loaded and we can
start to use it to test OpenERP's widgets.

Display Content
%%%%%%%%%%%%%%%

Widgets have a lot of methods and features, but let's start with the basics: display some data inside the widget and
how to instantiate a widget and display it.

The ``HomePage`` widget already has a ``start()`` method. That method is automatically called after the widget has been
instantiated and it has received the order to display its content. We will use it to display some content to the user.

To do so, we will also use the ``$el`` attribute that all widgets contain. That attribute is a jQuery object with a
reference to the HTML element that represent the root of our widget. A widget can contain multiple HTML elements, but
they must be contained inside one single element. By default, all widgets have an empty root element which is a
``<div>`` HTML element.

A ``<div>`` element in HTML is usually invisible for the user if it does not have any content. That explains why when
the ``instance.oepetstore.HomePage`` widget is displayed you can't see anything: it simply doesn't have any content. To
show something, we will use some simple jQuery methods on that object to add some HTML in our root element:

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            this.$el.append("<div>Hello dear OpenERP user!</div>");
        },
    });

That message will now appear when you go to the menu :menuselection:`Pet Store --> Pet Store --> Home Page` (remember you need to refresh
your web browser, although there is not need to restart OpenERP's server).

Now you should learn how to instantiate a widget and display its content. To do so, we will create a new widget:

::

    instance.oepetstore.GreetingsWidget = instance.web.Widget.extend({
        start: function() {
            this.$el.append("<div>We are so happy to see you again in this menu!</div>");
        },
    });

Now we want to display the ``instance.oepetstore.GreetingsWidget`` inside the home page. To do so we can use the
``append()`` method of ``Widget``:

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            this.$el.append("<div>Hello dear OpenERP user!</div>");
            var greeting = new instance.oepetstore.GreetingsWidget(this);
            greeting.appendTo(this.$el);
        },
    });

Here, the ``HomePage`` instantiate a ``GreetingsWidget`` (the first argument of the constructor of ``GreetingsWidget``
will be explained in the next part). Then it asks the ``GreetingsWidget`` to insert itself inside the DOM, more
precisely directly under the ``HomePage`` widget.

When the ``appendTo()`` method is called, it asks the widget to insert itself and to display its content. It's during
the call to ``appentTo()`` that the ``start()`` method will be called.

To check the consequences of that code, let's use Chrome's DOM explorer. But before that we will modify a little bit
our widgets to have some classes on some of our ``<div>`` elements so we can clearly see them in the explorer:

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            this.$el.addClass("oe_petstore_homepage");
            ...
        },
    });
    instance.oepetstore.GreetingsWidget = instance.web.Widget.extend({
        start: function() {
            this.$el.addClass("oe_petstore_greetings");
            ...
        },
    });

The result will be this if you can find the correct DOM part in the DOM explorer:

.. code-block:: html

    <div class="oe_petstore_homepage">
        <div>Hello dear OpenERP user!</div>
        <div class="oe_petstore_greetings">
            <div>We are so happy to see you again in this menu!</div>
        </div>
    </div>

Here we can clearly see the two ``<div>`` created implicitly by the ``Widget`` class, because we added some classes
on them. We can also see the two divs containing messages we created using the jQuery methods on ``$el``. Finally,
note the ``<div class="oe_petstore_greetings">`` element which represents the ``GreetingsWidget`` instance is *inside*
the ``<div class="oe_petstore_homepage">`` which represents the ``HomePage`` instance.

Widget Parents and Children
%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the previous part, we instantiated a widget using this syntax::

    new instance.oepetstore.GreetingsWidget(this);

The first argument is ``this``, which in that case was a ``HomePage`` instance. This serves to indicate the Widget what
other widget is his parent.

As we've seen, widgets are usually inserted in the DOM by another widget and *inside* that other widget. This means most
widgets are always a part of another widget. We call the container the *parent*, and the contained widget the *child*.

Due to multiple technical and conceptual reasons, it is necessary for a widget to know who is his parent and who are its
children. This is why we have that first parameter in the constructor of all widgets.

The ``getParent()`` method can be used to get the parent of a widget::

    instance.oepetstore.GreetingsWidget = instance.web.Widget.extend({
        start: function() {
            console.log(this.getParent().$el );
            // will print "div.oe_petstore_homepage" in the console
        },
    });

The ``getChildren()`` method can be used to get a list of its children::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            var greeting = new instance.oepetstore.GreetingsWidget(this);
            greeting.appendTo(this.$el);
            console.log(this.getChildren()[0].$el);
            // will print "div.oe_petstore_greetings" in the console
        },
    });

You should also remember that, when you override the ``init()`` method of a widget you should always put the parent as
first parameter are pass it to ``this._super()``:

::

    instance.oepetstore.GreetingsWidget = instance.web.Widget.extend({
        init: function(parent, name) {
            this._super(parent);
            this.name = name;
        },
    });

Finally, if a widget does not logically have a parent (ie: because it's the first widget you instantiate in an
application), you can give null as a parent instead:

    new instance.oepetstore.GreetingsWidget(null);

Destroying Widgets
%%%%%%%%%%%%%%%%%%

If you can display content to your users, you should also be able to erase it. This can simply be done using the
``destroy()`` method:

::

    greeting.destroy();

When a widget is destroyed it will first call ``destroy()`` on all its children. Then it erases itself from the DOM. The
recursive call to destroy from parents to children is very useful to clean properly complex structures of widgets and
avoid memory leaks that can easily appear in big JavaScript applications.

.. _qweb:

The QWeb Template Engine
------------------------

The previous part of the guide showed how to define widgets that are able to display HTML to the user. The example
``GreetingsWidget`` used a syntax like this:

::

    this.$el.append("<div>Hello dear OpenERP user!</div>");

This technically allow use to display any HTML, even it is very complex and require to be generated by code. Although
generating text using pure JavaScript is not very nice, that would necessitate to copy-paste a lot of HTML lines inside
our JavaScript source file, add the ``"`` character at the beginning and the end of each line, etc...

The problem is exactly the same in most programming languages needing to generate HTML. That's why they
typically use template engines. Example of template engines are Velocity, JSP (Java), Mako, Jinja (Python), Smarty (PHP),
etc...

In OpenERP we use a template engine developed specifically for OpenERP's web client. Its name is QWeb.

QWeb is an XML-based templating language, similar to `Genshi
<http://en.wikipedia.org/wiki/Genshi_(templating_language)>`_, `Thymeleaf <http://en.wikipedia.org/wiki/Thymeleaf>`_ or
`Facelets <http://en.wikipedia.org/wiki/Facelets>`_ with a few peculiarities:

* It's implemented fully in JavaScript and rendered in the browser.
* Each template file (XML files) contains multiple templates, where template engine usually have a 1:1 mapping between
  template files and templates.
* It has special support in OpenERP Web's ``instance.web.Widget``, though it can be used outside of OpenERP's web
  client (and it's possible to use ``instance.web.Widget`` without relying on QWeb).

The rationale behind using QWeb instead of existing javascript template engines is that its extension mechanism is very
similar to the OpenERP view inheritance mechanism. Like OpenERP views a QWeb template is an XML tree and therefore XPath
or DOM manipulations are easy to performs on it.

Using QWeb inside a Widget
%%%%%%%%%%%%%%%%%%%%%%%%%%

First let's define a simple QWeb template in ``oepetstore/static/src/xml/petstore.xml`` file, the exact meaning will be
explained later:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>

    <templates xml:space="preserve">
        <t t-name="HomePageTemplate">
            <div style="background-color: red;">This is some simple HTML</div>
        </t>
    </templates>

Now let's modify the ``HomePage`` class. Remember that enigmatic line at the beginning the the JavaScript source file?

::

    var QWeb = instance.web.qweb;

This is a line we recommend to copy-paste in all OpenERP web modules. It is the object giving access to all templates
defined in template files that were loaded by the web client. We can use the template we defined in our XML template
file like this:

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            this.$el.append(QWeb.render("HomePageTemplate"));
        },
    });

Calling the ``QWeb.render()`` method asks to render the template identified by the string passed as first parameter.

Another possibility commonly seen in OpenERP code is to use ``Widget``'s integration with QWeb:

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        template: "HomePageTemplate",
        start: function() {
            ...
        },
    });

When you put a ``template`` class attribute in a widget, the widget knows it has to call ``QWeb.render()`` to render
that template.

Please note there is a difference between those two syntaxes. When you use ``Widget``'s QWeb integration the
``QWeb.render()`` method is called *before* the widget calls ``start()``. It will also take the root element of the
rendered template and put it as a replacement of the default root element generated by the ``Widget`` class. This will
alter the behavior, so you should remember it.

QWeb Context
''''''''''''

Like with all template engines, QWeb templates can contain code able to manipulate data that is given to the template.
To pass data to QWeb, use the second argument to ``QWeb.render()``:

.. code-block:: xml

    <t t-name="HomePageTemplate">
        <div>Hello <t t-esc="name"/></div>
    </t>

::

    QWeb.render("HomePageTemplate", {name: "Nicolas"});

Result:

.. code-block:: html

    <div>Hello Nicolas</div>

When you use ``Widget``'s integration you can not pass additional data to the template. Instead the template will
have a unique ``widget`` variable which is a reference to the current widget:

.. code-block:: xml

    <t t-name="HomePageTemplate">
        <div>Hello <t t-esc="widget.name"/></div>
    </t>

::

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        template: "HomePageTemplate",
        init: function(parent) {
            this._super(parent);
            this.name = "Nicolas";
        },
        start: function() {
        },
    });

Result:

::
    <div>Hello Nicolas</div>

Template Declaration
''''''''''''''''''''

Now that we know everything about rendering templates we can try to understand QWeb's syntax.

All QWeb directives use XML attributes beginning with the prefix ``t-``. To declare new templates, we add a
``<t t-name="...">`` element into the XML template file inside the root element ``<template>``:

::

    <templates>
        <t t-name="HomePageTemplate">
            <div>This is some simple HTML</div>
        </t>
    </templates>

``t-name`` simply declares a template that can be called using ``QWeb.render()``.

Escaping
''''''''

To put some text in the HTML, use ``t-esc``:

::

    <t t-name="HomePageTemplate">
        <div>Hello <t t-esc="name"/></div>
    </t>


This will output the variable ``name`` and escape its content in case it contains some characters that looks like HTML.
Please note the attribute ``t-esc`` can contain any type of JavaScript expression:

::

    <t t-name="HomePageTemplate">
        <div><t t-esc="3+5"/></div>
    </t>

Will render:

::

    <div>8</div>

Outputting HTML
'''''''''''''''

If you know you have some HTML contained in a variable, use ``t-raw`` instead of ``t-esc``:

::

    <t t-name="HomePageTemplate">
        <div><t t-raw="some_html"/></div>
    </t>

If
''

The basic alternative block of QWeb is ``t-if``:

::

    <t t-name="HomePageTemplate">
        <div>
            <t t-if="true == true">
                true is true
            </t>
            <t t-if="true == false">
                true is not true
            </t>
        </div>
    </t>

Although QWeb does not contains any structure for else.

Foreach
'''''''

To iterate on a list, use ``t-foreach`` and ``t-as``:

::

    <t t-name="HomePageTemplate">
        <div>
            <t t-foreach="names" t-as="name">
                <div>
                    Hello <t t-esc="name"/>
                </div>
            </t>
        </div>
    </t>

Setting the Value of an XML Attribute
'''''''''''''''''''''''''''''''''''''

QWeb has a special syntax to set the value of an attribute. You must use ``t-att-xxx`` and replace ``xxx`` with the
name of the attribute:

::

    <t t-name="HomePageTemplate">
        <div>
            Input your name:
            <input type="text" t-att-value="defaultName"/>
        </div>
    </t>

To Learn More About QWeb
''''''''''''''''''''''''

This guide does not pretend to be a reference for QWeb, please see the documentation for more information:
https://doc.openerp.com/trunk/web/qweb/ .

Exercise
''''''''

.. topic:: Exercise - Usage of QWeb in Widgets

    Create a widget whose constructor contains two parameters aside from ``parent``: ``product_names`` and ``color``.
    ``product_names`` is a list of strings, each one being a name of product. ``color`` is a string containing a color
    in CSS color format (ie: ``#000000`` for black). That widget should display the given product names one under the
    other, each one in a separate box with a background color with the value of ``color`` and a border. You must use
    QWeb to render the HTML. This exercise will necessitate some CSS that you should put in
    ``oepetstore/static/src/css/petstore.css``. Display that widget in the ``HomePage`` widget with a list of five
    products and green as the background color for boxes.

.. only:: not nosolutions

    **Solution:**

    .. code-block:: javascript

        openerp.oepetstore = function(instance) {
            var _t = instance.web._t,
                _lt = instance.web._lt;
            var QWeb = instance.web.qweb;

            instance.oepetstore = {};

            instance.oepetstore.HomePage = instance.web.Widget.extend({
                start: function() {
                    var products = new instance.oepetstore.ProductsWidget(this, ["cpu", "mouse", "keyboard", "graphic card", "screen"], "#00FF00");
                    products.appendTo(this.$el);
                },
            });

            instance.oepetstore.ProductsWidget = instance.web.Widget.extend({
                template: "ProductsWidget",
                init: function(parent, products, color) {
                    this._super(parent);
                    this.products = products;
                    this.color = color;
                },
            });
            
            instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');
        }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8"?>

        <templates xml:space="preserve">
            <t t-name="ProductsWidget">
                <div>
                    <t t-foreach="widget.products" t-as="product">
                        <span class="oe_products_item" t-att-style="'background-color: ' + widget.color + ';'"><t t-esc="product"/></span><br/>
                    </t>
                </div>
            </t>
        </templates>

    .. code-block:: css

        .oe_products_item {
            display: inline-block;
            padding: 3px;
            margin: 5px;
            border: 1px solid black;
            border-radius: 3px;
        }

    .. image:: img/qweb.png
       :align: center
       :width: 70%

Widget Events and Properties
----------------------------

Widgets still have more helper to learn. One of the more complex (and useful) one is the event system. Events are also
closely related to the widget properties.

Events
%%%%%%

Widgets are able to fire events in a similar way most components in existing graphical user interfaces libraries (Qt,
GTK, Swing,...) handle them. Example:

::

    instance.oepetstore.ConfirmWidget = instance.web.Widget.extend({
        start: function() {
            var self = this;
            this.$el.append("<div>Are you sure you want to perform this action?</div>" +
                "<button class='ok_button'>Ok</button>" +
                "<button class='cancel_button'>Cancel</button>");
            this.$el.find("button.ok_button").click(function() {
                self.trigger("user_choose", true);
            });
            this.$el.find("button.cancel_button").click(function() {
                self.trigger("user_choose", false);
            });
        },
    });

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            var widget = new instance.oepetstore.ConfirmWidget(this);
            widget.on("user_choose", this, this.user_choose);
            widget.appendTo(this.$el);
        },
        user_choose: function(confirm) {
            if (confirm) {
                console.log("The user agreed to continue");
            } else {
                console.log("The user refused to continue");
            }
        },
    });

First, we will explain what this example is supposed to do. We create a generic widget to ask the user if he really
wants to do an action that could have important consequences (a type widget heavily used in Windows). To do so, we put
two buttons in the widget. Then we bind jQuery events to know when the user click these buttons.

.. note::

    It could be hard to understand this particular line:

    ::

        var self = this;

    Remember, in JavaScript the variable ``this`` is a variable that is passed implicitly to all functions. It allows us
    to know which is the object if function is used like a method. Each declared function has its own ``this``. So, when
    we declare a function inside a function, that new function will have its own ``this`` that could be different from
    the ``this`` of the parent function. If we want to remember the original object the simplest method is to store a
    reference in a variable. By convention in OpenERP we very often name that variable ``self`` because it's the
    equivalent of ``this`` in Python.

Since our widget is supposed to be generic, it should not perform any precise action by itself. So, we simply make it
trigger and event named ``user_choose`` by using the ``trigger()`` method.

``Widget.trigger(event_name [, ...])`` takes as first argument the name of the event to trigger. Then it can takes any
number of additional arguments. These arguments will be passed to all the event listeners.

Then we modify the ``HomePage`` widget to instantiate a ``ConfirmWidget`` and listen to its ``user_choose`` event by
calling the ``on()`` method.

``Widget.on(event_name, object, func)`` allows to bind a function to be called when the event identified by event_name
is ``triggered``. The ``func`` argument is the function to call and ``object`` is the object to which that function is
related if it is a method. The binded function will be called with the additional arguments of ``trigger()`` if it has
any. Example:

::

    start: function() {
        var widget = ...
        widget.on("my_event", this, this.my_event_triggered);
        widget.trigger("my_event", 1, 2, 3);
    },
    my_event_triggered: function(a, b, c) {
        console.log(a, b, c);
        // will print "1 2 3"
    }

Properties
%%%%%%%%%%

Properties are very similar to normal object attributes. They allow to set data on an object but with an additional
feature: it triggers events when a property's value has changed.

::

    start: function() {
        this.widget = ...
        this.widget.on("change:name", this, this.name_changed);
        this.widget.set("name", "Nicolas");
    },
    name_changed: function() {
        console.log("The new value of the property 'name' is", this.widget.get("name"));
    }

``Widget.set(name, value)`` allows to set the value of property. If the value changed (or it didn't had a value
previously) the object will trigger a ``change:xxx`` where ``xxx`` is the name of the property.

``Widget.get(name)`` allows to retrieve the value of a property.

Exercise
%%%%%%%%

.. topic:: Exercise - Widget Properties and Events

    Create a widget ``ColorInputWidget`` that will display 3 ``<input type="text">``. Each of these ``<input>`` is
    dedicated to type a hexadecimal number from 00 to FF. When any of these ``<input>`` is modified by the user the
    widget must query the content of the three ``<input>``, concatenate their values to have a complete CSS color code
    (ie: ``#00FF00``) and put the result in a property named ``color``. Please note the jQuery ``change()`` event that
    you can bind on any HTML ``<input>`` element and the ``val()`` method that can query the current value of that
    ``<input>`` could be useful to you for this exercise.

    Then, modify the ``HomePage`` widget to instantiate ``ColorInputWidget`` and display it. The ``HomePage`` widget
    should also display an empty rectangle. That rectangle must always, at any moment, have the same background color
    than the color in the ``color`` property of the ``ColorInputWidget`` instance.

    Use QWeb to generate all HTML.

.. only:: not nosolutions

    **Solution:**

    ::

        openerp.oepetstore = function(instance) {
            var _t = instance.web._t,
                _lt = instance.web._lt;
            var QWeb = instance.web.qweb;

            instance.oepetstore = {};

            instance.oepetstore.ColorInputWidget = instance.web.Widget.extend({
                template: "ColorInputWidget",
                start: function() {
                    var self = this;
                    this.$el.find("input").change(function() {
                        self.input_changed();
                    });
                    self.input_changed();
                },
                input_changed: function(confirm) {
                    var color = "#";
                    color += this.$el.find(".oe_color_red").val();
                    color += this.$el.find(".oe_color_green").val();
                    color += this.$el.find(".oe_color_blue").val();
                    this.set("color", color);
                },
            });

            instance.oepetstore.HomePage = instance.web.Widget.extend({
                template: "HomePage",
                start: function() {
                    this.colorInput = new instance.oepetstore.ColorInputWidget(this);
                    this.colorInput.on("change:color", this, this.color_changed);
                    this.colorInput.appendTo(this.$el);
                },
                color_changed: function() {
                    this.$el.find(".oe_color_div").css("background-color", this.colorInput.get("color"));
                },
            });

            instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');
        }

    ::

        <?xml version="1.0" encoding="UTF-8"?>

        <templates xml:space="preserve">
            <t t-name="ColorInputWidget">
                <div>
                    Red: <input type="text" class="oe_color_red" value="00"></input><br />
                    Green: <input type="text" class="oe_color_green" value="00"></input><br />
                    Blue: <input type="text" class="oe_color_blue" value="00"></input><br />
                </div>
            </t>
            <t t-name="HomePage">
                <div>
                    <div class="oe_color_div"></div>
                </div>
            </t>
        </templates>

    ::

        .oe_color_div {
            width: 100px;
            height: 100px;
            margin: 10px;
        }

    .. note::

        jQuery's ``css()`` method allows to set a css property.

Widget Helpers
--------------

We've seen the basics of the ``Widget`` class, QWeb and the events/properties system. There are still some more useful
methods proposed by this class.

``Widget``'s jQuery Selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It is very common to need to select a precise element inside a widget. In the previous part of this guide we've seen
a lot of uses of the ``find()`` method of jQuery objects:

::

    this.$el.find("input.my_input")...

``Widget`` provides a shorter syntax that does the same thing with the ``$()`` method:

::

    instance.oepetstore.MyWidget = instance.web.Widget.extend({
        start: function() {
            this.$("input.my_input")...
        },
    });

.. note::
    
    We strongly advise you against using directly the global jQuery function ``$()`` like we did in the previous
    chapter were we explained the jQuery library and jQuery selectors. That type of global selection is sufficient for
    simple applications but is not a good idea in real, big web applications. The reason is simple: when you create a
    new type of widget you never know how many times it will be instantiated. Since the ``$()`` global function 
    operates in *the whole HTML displayed in the browser*, if you instantiate a widget 2 times and use that function you
    will incorrectly select the content of another instance of your widget. That's why you must restrict the jQuery
    selections to HTML which is located *inside* your widget most of the time.

    Applying the same logic, you can also guess it is a very bad idea to try to use HTML ids in any widget. If the
    widget is instantiated 2 times you will have 2 different HTML element in the whole application that have the same
    id. And that is an error by itself. So you should stick to CSS classes to mark your HTML elements in all cases.

Easier DOM Events Binding
%%%%%%%%%%%%%%%%%%%%%%%%%

In the previous part, we had to bind a lot of HTML element events like ``click()`` or ``change()``. Now that we have
the ``$()`` method to simplify code a little, let's see how it would look like:

::

    instance.oepetstore.MyWidget = instance.web.Widget.extend({
        start: function() {
            var self = this;
            this.$(".my_button").click(function() {
                self.button_clicked();
            });
        },
        button_clicked: function() {
            ..
        },
    });

It's still a bit long to type. That's why there is an even more simple syntax for that:

::

    instance.oepetstore.MyWidget = instance.web.Widget.extend({
        events: {
            "click .my_button": "button_clicked",
        },
        button_clicked: function() {
            ..
        }
    });

.. warning::

    It's important to differentiate the jQuery events that are triggered on DOM elements and events of the widgets. The
    ``event`` class attribute *is a helper to help binding jQuery events*, it has nothing to do with the widget events
    that can be binded using the ``on()`` method.

The ``event`` class attribute is a dictionary that allows to define jQuery events with a shorter syntax.

The key is a string with 2 different parts separated with a space. The first part is the name of the event, the second
one is the jQuery selector. So the key ``click .my_button`` will bind the event ``click`` on the elements matching the
selector ``my_button``.

The value is a string with the name of the method to call on the current object.

Development Guidelines
%%%%%%%%%%%%%%%%%%%%%%

As explained in the prerequisites to read this guide, you should already know HTML and CSS. But developing web
applications in JavaScript or developing web modules for OpenERP require to be more strict than you will usually be
when simply creating static web pages with CSS to style them. So these guidelines should be followed if you want to
have manageable projects and avoid bugs or common mistakes:

* Identifiers (``id`` attribute) should be avoided. In generic applications and modules, ``id`` limits the re-usability
  of components and tends to make code more brittle. Just about all the time, they can be replaced with nothing, with
  classes or with keeping a reference to a DOM node or a jQuery element around.

  .. note::

      If it is absolutely necessary to have an ``id`` (because a third-party library requires one and can't take a DOM
      element), it should be generated with ``_.uniqueId()``.

* Avoid predictable/common CSS class names. Class names such as "content" or "navigation" might match the desired
  meaning/semantics, but it is likely an other developer will have the same need, creating a naming conflict and
  unintended behavior. Generic class names should be prefixed with e.g. the name of the component they belong to
  (creating "informal" namespaces, much as in C or Objective-C).

* Global selectors should be avoided. Because a component may be used several times in a single page (an example in
  OpenERP is dashboards), queries should be restricted to a given component's scope. Unfiltered selections such as
  ``$(selector)`` or ``document.querySelectorAll(selector)`` will generally lead to unintended or incorrect behavior.
  OpenERP Web's ``Widget`` has an attribute providing its DOM root (``Widget.$el``), and a shortcut to select nodes
  directly (``Widget.$()``).

* More generally, never assume your components own or controls anything beyond its own personal ``$el``.

* HTML templating/rendering should use QWeb unless absolutely trivial.

* All interactive components (components displaying information to the screen or intercepting DOM events) must inherit
  from Widget and correctly implement and use its API and life cycle.

Communication with the OpenERP Server
-------------------------------------

Now you should know everything you need to display any type of graphical user interface with your OpenERP modules.
Still, OpenERP is a database-centric application so it's still not very useful if you can't query data from the
database.

As a reminder, in OpenERP you are not supposed to directly query data from the PostgreSQL database, you will always
use the build-in ORM (Object-Relational Mapping) and more precisely the OpenERP *models*.

Contacting Models
%%%%%%%%%%%%%%%%%

In the previous chapter we explained how to send HTTP requests to the web server using the ``$.ajax()`` method and the
JSON format. It is useful to know how to make a JavaScript application communicate with its web server using these
tools, but it's still a little bit low-level to be used in a complex application like OpenERP.

When the web client contacts the OpenERP server it has to pass additional data like the necessary information to
authenticate the current user. There is also some more complexity due to OpenERP models that need a higher-level
communication protocol to be used.

This is why you will not use directly ``$.ajax()`` to communicate with the server. The web client framework provides
classes to abstract that protocol.

To demonstrate this, the file ``petstore.py`` already contains a small model with a sample method:

.. code-block:: python

    class message_of_the_day(osv.osv):
        _name = "message_of_the_day"

        def my_method(self, cr, uid, context=None):
            return {"hello": "world"}
        
        _columns = {
            'message': fields.text(string="Message"),
            'color': fields.char(string="Color", size=20),
        }

If you know OpenERP models that code should be familiar to you. This model declares a table named ``message_of_the_day``
with two fields. It also has a method ``my_method()`` that doesn't do much except return a dictionary.

Here is a sample widget that calls ``my_method()`` and displays the result:

.. code-block:: javascript

    instance.oepetstore.HomePage = instance.web.Widget.extend({
        start: function() {
            var self = this;
            var model = new instance.web.Model("message_of_the_day");
            model.call("my_method", [], {context: new instance.web.CompoundContext()}).then(function(result) {
                self.$el.append("<div>Hello " + result["hello"] + "</div>");
                // will show "Hello world" to the user
            });
        },
    });

The class used to contact OpenERP models is ``instance.web.Model``. When you instantiate it, you must give as first
argument to its constructor the name of the model you want to contact in OpenERP. (Here it is ``message_of_the_day``,
the model created for this example, but it could be any other model like ``res.partner``.)

``call(name, args, kwargs)`` is the method of ``Model`` used to call any method of an OpenERP server-side model. Here
are its arguments:

* ``name`` is the name of the method to call on the model. Here it is the method named ``my_method``.
* ``args`` is a list of positional arguments to give to the method. The sample ``my_method()`` method does not contain
  any particular argument we want to give to it, so here is another example:

  .. code-block:: python

      def my_method2(self, cr, uid, a, b, c, context=None): ...

  .. code-block:: javascript

      model.call("my_method", [1, 2, 3], ...
      // with this a=1, b=2 and c=3

* ``kwargs`` is a list of named arguments to give to the method. In the example, we have one named argument which is
  a bit special: ``context``. It's given a value that may seem very strange right now:
  ``new instance.web.CompoundContext()``. The meaning of that argument will be explained later. Right now you should
  just know the ``kwargs`` argument allows to give arguments to the Python method by name instead of position. Example:

  .. code-block:: python

      def my_method2(self, cr, uid, a, b, c, context=None): ...

  .. code-block:: javascript

      model.call("my_method", [], {a: 1, b: 2, c: 3, ...
      // with this a=1, b=2 and c=3

.. note::

    If you take a look at the ``my_method()``'s declaration in Python, you can see it has two arguments named ``cr`` and
    ``uid``:

    .. code-block:: python

        def my_method(self, cr, uid, context=None):

    You could have noticed we do not give theses arguments to the server when we call that method from JavaScript. That
    is because theses arguments that have to be declared in all models' methods are never sent from the OpenERP client.
    These arguments are added implicitly by the OpenERP server. The first one is an object called the *cursor* that
    allows communication with the database. The second one is the id of the currently logged in user.

``call()`` returns a deferred resolved with the value returned by the model's method as first argument. If you don't
know what deferreds are, take a look at the previous chapter (the part about HTTP requests in jQuery).

CompoundContext
%%%%%%%%%%%%%%%

In the previous part, we avoided to explain the strange ``context`` argument in the call to our model's method:

.. code-block:: javascript

    model.call("my_method", [], {context: new instance.web.CompoundContext()})

In OpenERP, models' methods should always have an argument named ``context``:

.. code-block:: python

    def my_method(self, cr, uid, context=None): ...

The context is like a "magic" argument that the web client will always give to the server when calling a method. The
context is a dictionary containing multiple keys. One of the most important key is the language of the user, used by the
server to translate all the messages of the application. Another one is the time zone of the user, used to compute
correctly dates and times if OpenERP is used by people in different countries.

The ``argument`` is necessary in all methods, because if we forget it bad things could happen (like the application not
being translated correctly). That's why, when you call a model's method, you should always give it to that argument. The
solution to achieve that is to use the ``instance.web.CompoundContext`` class.

``CompoundContext`` is a class used to pass the user's context (with language, time zone, etc...) to the server as well
as adding new keys to the context (some models' methods use arbitrary keys added to the context). It is created by
giving to its constructor any number of dictionaries or other ``CompoundContext`` instances. It will merge all those
contexts before sending them to the server.

.. code-block:: javascript

    model.call("my_method", [], {context: new instance.web.CompoundContext({'new_key': 'key_value'})})

.. code-block:: python

    def display_context(self, cr, uid, context=None):
        print context
        // will print: {'lang': 'en_US', 'new_key': 'key_value', 'tz': 'Europe/Brussels', 'uid': 1}

You can see the dictionary in the argument ``context`` contains some keys that are related to the configuration of the
current user in OpenERP plus the ``new_key`` key that was added when instantiating ``CompoundContext``.

To resume, you should always add an instance of ``instance.web.CompoundContext`` in all calls to a model's method.

Queries
%%%%%%%

If you know OpenERP module development, you should already know everything necessary to communicate with models and
make them do what you want. But there is still a small helper that could be useful to you : ``query()``.

``query()`` is a shortcut for the usual combination of ``search`` and ``read`` methods in OpenERP models. It allows
to search records and get their data with a shorter syntax. Example:

.. code-block:: javascript

    model.query(['name', 'login', 'user_email', 'signature'])
         .filter([['active', '=', true], ['company_id', '=', main_company]])
         .limit(15)
         .all().then(function (users) {
        // do work with users records
    });

``query()`` takes as argument a list of fields to query in the model. It returns an instance of the
``instance.web.Query`` class.

``Query`` is a class representing the query you are trying to construct before sending it to the server. It has 
multiple methods you can call to customize the query. All these methods will return the current instance of ``Query``:

* ``filter`` allows to specify an OpenERP *domain*. As a reminder, a domain in OpenERP is a list of conditions, each
  condition is a list it self.
* ``limit`` sets a limit to the number of records returned.

When you have customized you query, you can call the ``all()`` method. It will performs the real query to the server and
return a deferred resolved with the result. The result is the same thing return by the model's method ``read()`` (a list
of dictionaries containing the asked fields).

To have more information about the ``query()`` helper, see the reference documentation:
https://doc.openerp.com/trunk/web/rpc/ .

Exercises
---------

.. topic:: Exercise - Message of the Day

    Create a widget ``MessageOfTheDay`` that will display the message contained in the last record of the
    ``message_of_the_day``. The widget should query the message as soon as it is inserted the the DOM and display the
    message to the user. Display that widget on the home page of the OpenERP Pet Store module.

.. only:: not nosolutions

    **Solution:**

    .. code-block:: javascript

        openerp.oepetstore = function(instance) {
            var _t = instance.web._t,
                _lt = instance.web._lt;
            var QWeb = instance.web.qweb;

            instance.oepetstore = {};

            instance.oepetstore.HomePage = instance.web.Widget.extend({
                template: "HomePage",
                start: function() {
                    var motd = new instance.oepetstore.MessageOfTheDay(this);
                    motd.appendTo(this.$el);
                },
            });

            instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');

            instance.oepetstore.MessageOfTheDay = instance.web.Widget.extend({
                template: "MessageofTheDay",
                init: function() {
                    this._super.apply(this, arguments);
                },
                start: function() {
                    var self = this;
                    new instance.web.Model("message_of_the_day").query(["message"]).first().then(function(result) {
                        self.$(".oe_mywidget_message_of_the_day").text(result.message);
                    });
                },
            });

        }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8"?>

        <templates xml:space="preserve">
            <t t-name="HomePage">
                <div class="oe_petstore_homepage">
                </div>
            </t>
            <t t-name="MessageofTheDay">
                <div class="oe_petstore_motd">
                    <p class="oe_mywidget_message_of_the_day"></p>
                </div>
            </t>
        </templates>

    .. code-block:: css

        .oe_petstore_motd {
            margin: 5px;
            padding: 5px;
            border-radius: 3px;
            background-color: #F0EEEE;
        }

.. topic:: Exercise - Pet Toys List

    Create a widget ``PetToysList`` that will display 5 toys on the home page with their names and their images.

    In this OpenERP addon, the pet toys are not stored in a new table like for the message of the day. They are in the
    table ``product.product``. If you click on the menu item ``Pet Store > Pet Store > Pet Toys`` you will be able to
    see them. Pet toys are identified by the category named ``Pet Toys``. You could need to document yourself on the
    model ``product.product`` to be able to create a domain to select pet toys and not all the products.

    To display the images of the pet toys, you should know that images in OpenERP can be queried from the database like
    any other fields, but you will obtain a string containing Base64-encoded binary. There is a little trick to display
    images in Base64 format in HTML:

    .. code-block:: html

        <img class="oe_kanban_image" src="data:image/png;base64,${replace this by base64}"></image>

    The ``PetToysList`` widget should be displayed on the home page on the right of the ``MessageOfTheDay`` widget. You
    will need to make some layout with CSS to achieve this.

.. only:: not nosolutions

    **Solution:**

    .. code-block:: javascript

        openerp.oepetstore = function(instance) {
            var _t = instance.web._t,
                _lt = instance.web._lt;
            var QWeb = instance.web.qweb;

            instance.oepetstore = {};

            instance.oepetstore.HomePage = instance.web.Widget.extend({
                template: "HomePage",
                start: function() {
                    var pettoys = new instance.oepetstore.PetToysList(this);
                    pettoys.appendTo(this.$(".oe_petstore_homepage_left"));
                    var motd = new instance.oepetstore.MessageOfTheDay(this);
                    motd.appendTo(this.$(".oe_petstore_homepage_right"));
                },
            });

            instance.web.client_actions.add('petstore.homepage', 'instance.oepetstore.HomePage');

            instance.oepetstore.MessageOfTheDay = instance.web.Widget.extend({
                template: "MessageofTheDay",
                init: function() {
                    this._super.apply(this, arguments);
                },
                start: function() {
                    var self = this;
                    new instance.web.Model("message_of_the_day").query(["message"]).first().then(function(result) {
                        self.$(".oe_mywidget_message_of_the_day").text(result.message);
                    });
                },
            });

            instance.oepetstore.PetToysList = instance.web.Widget.extend({
                template: "PetToysList",
                start: function() {
                    var self = this;
                    new instance.web.Model("product.product").query(["name", "image"])
                        .filter([["categ_id.name", "=", "Pet Toys"]]).limit(5).all().then(function(result) {
                        _.each(result, function(item) {
                            var $item = $(QWeb.render("PetToy", {item: item}));
                            self.$el.append($item);
                        });
                    });
                },
            });

        }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8"?>

        <templates xml:space="preserve">
            <t t-name="HomePage">
                <div class="oe_petstore_homepage">
                    <div class="oe_petstore_homepage_left"></div>
                    <div class="oe_petstore_homepage_right"></div>
                </div>
            </t>
            <t t-name="MessageofTheDay">
                <div class="oe_petstore_motd">
                    <p class="oe_mywidget_message_of_the_day"></p>
                </div>
            </t>
            <t t-name="PetToysList">
                <div class="oe_petstore_pettoyslist">
                </div>
            </t>
            <t t-name="PetToy">
                <div class="oe_petstore_pettoy">
                    <p><t t-esc="item.name"/></p>
                    <p><img t-att-src="'data:image/jpg;base64,'+item.image"/></p>
                </div>
            </t>
        </templates>

    .. code-block:: css

        .oe_petstore_homepage {
            display: table;
        }

        .oe_petstore_homepage_left {
            display: table-cell;
            width : 300px;
        }

        .oe_petstore_homepage_right {
            display: table-cell;
            width : 300px;
        }

        .oe_petstore_motd {
            margin: 5px;
            padding: 5px;
            border-radius: 3px;
            background-color: #F0EEEE;
        }

        .oe_petstore_pettoyslist { 
            padding: 5px;
        }

        .oe_petstore_pettoy {
            margin: 5px;
            padding: 5px;
            border-radius: 3px;
            background-color: #F0EEEE;
        }
